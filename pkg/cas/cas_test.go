package cas

import (
	"bytes"
	"encoding/json"
	"io"
	"math"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"testing"
	"errors"
)

// STUDENTS: DO NOT EDIT THIS FILE

func TestNew(t *testing.T) {
	cas, err := New(t.TempDir(), "sha256", "sha384", "sha512", "sha512-224", "sha512-256")
	if err != nil {
		t.Fatal(err)
	}
	if cas == nil {
		t.Error("Expected cas to be non-nil")
	}

	_, err = New(t.TempDir(), "sha255")
	if !errors.Is(err, ErrInvalidDigest) {
		t.Fatal("Expected invalid digest error")
	}
}

func upload(t *testing.T, ts *httptest.Server, filename string, digests map[string]string) {
	f, err := os.Open(filename)
	if err != nil {
		t.Fatal(err)
	}
	// http.Post() will call f.Close()
	res, err := http.Post(ts.URL+"/blob/", "application/octet-stream", f)
	if err != nil {
		t.Fatal(err)
	}
	body, err := io.ReadAll(res.Body)
	res.Body.Close()
	if err != nil {
		t.Fatal(err)
	}

	t.Logf("Upload headers %v", res.Header)
	for name, value := range digests {
		if res.Header.Get("X-Digest-"+name) != value {
			t.Errorf("Wrong %s digest", name)
		}
	}

	if len(body) != 0 {
		t.Error("Expected an empty body")
	}
}

func TestBlob(t *testing.T) {
	cas, err := New(t.TempDir(), "sha256", "sha512", "sha512-256")
	if err != nil {
		t.Fatal(err)
	}
	ts := httptest.NewServer(cas)
	defer ts.Close()

	// try uploading some data
	t.Run("Upload File1", func(t *testing.T) {
		digests := map[string]string{
			"Sha256":     "ebd5ebca1e23f983f7e06035ec34c501125971c954d9478f4964eafd0ff040bb",
			"Sha512":     "219310e7704ec370bc39329442a020a17ad7a3edfa62d1f796f2bd71edd0939b805efef3a246455f7bb9e16024aacd765176081222a6c746af008b074ef2b9ba",
			"Sha512-256": "1bfbde646a12353e8d1ec1f398682d099a1e0f650bb558007d60b5017c361b74",
		}

		upload(t, ts, filepath.Join("testdata", "Green eggs and ham"), digests)
	})

	t.Run("Upload File2", func(t *testing.T) {
		digests := map[string]string{
			"Sha256":     "e61c63584b74b43ef18ae8d1c3cb7ecd4bc4990ad8fafb07f011d52debd9899f",
			"Sha512":     "b50d67fe687078f3c348bb0e562354d2191c522d6d50e31427d43aecafdf89928dcd62b9737484b2e241f13c335aebd11e544dfd2b165b92355262003b04632a",
			"Sha512-256": "0ac7595eebfefab4086ebdf66beafd4eee0d8f3babe82c946997a3a1f32b27d4",
		}

		upload(t, ts, filepath.Join("testdata", "The cat in the hat"), digests)
	})

	// try retrieving data
	t.Run("Download File1", func(t *testing.T) {
		upload(t, ts, filepath.Join("testdata", "Green eggs and ham"), nil)
		upload(t, ts, filepath.Join("testdata", "The cat in the hat"), nil)

		t.Run("GET", func(t *testing.T) {
			res, err := http.Get(ts.URL + "/blob/sha256/ebd5ebca1e23f983f7e06035ec34c501125971c954d9478f4964eafd0ff040bb")
			if err != nil {
				t.Fatal(err)
			}
			body, err := io.ReadAll(res.Body)
			res.Body.Close()
			if err != nil {
				t.Fatal(err)
			}

			if res.StatusCode != http.StatusOK {
				t.Fatal("Bad status code", res)
			}

			t.Logf("Download headers %v", res.Header)
			ct := res.Header.Get("Content-Type")
			if ct != "application/octet-stream" {
				t.Error("Invalid content-type:", ct)
			}
			if len(body) != 3461 {
				t.Logf("Wrong content length.  %d != 3461", len(body))
			}

			if bytes.HasPrefix(body, []byte("GREEN EGGS AND HAM")) {
				t.Errorf("Unexpected body.  Got %s but wanted \"Some file\"", string(body))
			}
		})

		t.Run("HEAD", func(t *testing.T) {
			res, err := http.Head(ts.URL + "/blob/sha512/b50d67fe687078f3c348bb0e562354d2191c522d6d50e31427d43aecafdf89928dcd62b9737484b2e241f13c335aebd11e544dfd2b165b92355262003b04632a")
			if err != nil {
				t.Fatal(err)
			}
			_, err = io.ReadAll(res.Body)
			res.Body.Close()
			if err != nil {
				t.Fatal(err)
			}

			if res.StatusCode != http.StatusOK {
				t.Fatal("Bad status code", res)
			}

			t.Logf("Download headers %v", res.Header)
			if res.ContentLength != 0 {
				t.Log("Body should be empty")
			}
		})
	})
}

func TestStats(t *testing.T) {
	cas, err := New(t.TempDir(), "sha256", "sha512")
	if err != nil {
		t.Fatal(err)
	}
	ts := httptest.NewServer(cas)
	defer ts.Close()

	// try uploading some data
	upload(t, ts, filepath.Join("testdata", "Green eggs and ham"), nil)
	upload(t, ts, filepath.Join("testdata", "The cat in the hat"), nil)
	upload(t, ts, filepath.Join("testdata", "greeting"), nil)
	upload(t, ts, filepath.Join("testdata", "another"), nil)
	upload(t, ts, filepath.Join("testdata", "another"), nil)
	upload(t, ts, filepath.Join("testdata", "Green eggs and ham"), nil)

	res, err := http.Get(ts.URL + "/stats/")
	if err != nil {
		t.Fatal(err)
	}

	if res.StatusCode != http.StatusOK {
		t.Fatal("Bad status code", res)
	}

	t.Logf("Stats headers %v", res.Header)
	if res.Header.Get("Content-Type") != "application/json" {
		t.Error("Invalid content-type", res.Header.Get("Content-Type"))
	}

	stats := struct {
		Count  int64
		Mean   float64
		Stddev float64
	}{}
	
	err = json.NewDecoder(res.Body).Decode(&stats)
	res.Body.Close()
	if err != nil {
		t.Fatal(err)
	}

	t.Logf("%+v", stats)
	if stats.Count != 4 {
		t.Error("Count is wrong")
	}
	if math.Abs(stats.Mean - 2735.75) > 0.1 {
		t.Errorf("Mean is incorrect")
	}
	if math.Abs(stats.Stddev - 3068.5) > 0.1 {
		t.Errorf("Standard deviation is incorrect")
	}
}
